{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\User\\\\Documents\\\\Projects\\\\GPL3\\\\point-game\\\\src\\\\Page.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport { Stage, Layer, Line, Circle } from 'react-konva';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Page = ({\n  numRows,\n  numCols,\n  plateau,\n  setPlateau\n}) => {\n  _s();\n  const [currentPlayer, setCurrentPlayer] = useState(1);\n  let totalPlayers = 2;\n  const width = 750;\n  const height = 400;\n  const marginTop = 100;\n  const marginBottom = 60;\n  const marginLeft = 120;\n  const marginRight = 40;\n  let a = width / numCols;\n  let b = height / numRows;\n  let scale = a > b ? Math.floor(a) : Math.floor(a); // �chelle pour les graduations\n  scale = 50;\n  const [points, setPoints] = useState([]); // �tat pour les points\n\n  // Tableaux pour stocker les points de chaque joueur avec leur couleur\n  const [playerPoints, setPlayerPoints] = useState(Array.from({\n    length: totalPlayers\n  }, () => []));\n  const renderHorizontalLines = () => {\n    const lines = [];\n    for (let i = 0; i <= numRows; i++) {\n      lines.push( /*#__PURE__*/_jsxDEV(Line, {\n        points: [0, marginTop + i * scale, marginLeft + width + marginRight, marginTop + i * scale],\n        stroke: \"#ddd\"\n      }, `hline${i}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 31,\n        columnNumber: 17\n      }, this));\n    }\n    return lines;\n  };\n  const renderVerticalLines = () => {\n    const lines = [];\n    for (let i = 0; i <= numCols; i++) {\n      lines.push( /*#__PURE__*/_jsxDEV(Line, {\n        points: [marginLeft + i * scale, 0, marginLeft + i * scale, marginTop + height + marginBottom],\n        stroke: \"#ddd\"\n      }, `vline${i}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 45,\n        columnNumber: 17\n      }, this));\n    }\n    return lines;\n  };\n\n  // Calculer l'intersection la plus proche\n  const getClosestIntersection = (x, y) => {\n    const closestX = Math.round((x - marginLeft) / scale) * scale;\n    const closestY = Math.round((y - marginTop) / scale) * scale;\n    return {\n      x: closestX + marginLeft,\n      y: closestY + marginTop\n    };\n  };\n  const isValidPoint = (x, y) => {\n    return x > marginLeft - 20 && x < marginLeft + width + 20 && y > marginTop - 20 && y < marginTop + height + 50;\n  };\n  const [mousePos, setMousePos] = useState({\n    x: 0,\n    y: 0\n  }); // �tat pour la position de la souris\n\n  // G�rer le mouvement de la souris \n  const handleMouseMove = event => {/*\r\n                                    const { x, y } = event.target.getStage().getPointerPosition();\r\n                                    const { x: closestX, y: closestY } = getClosestIntersection(x, y);\r\n                                    if (isValidPoint(x, y)) {\r\n                                    setMousePos({ x: closestX, y: closestY });\r\n                                    }*/\n  };\n\n  // ************************************************************************************************************* //\n  // *********** ATO NO MIASA LE GAME **************************************************************************** //\n  // ************************************************************************************************************* //\n  const handleClick = event => {\n    const {\n      x,\n      y\n    } = event.target.getStage().getPointerPosition();\n    const {\n      x: closestX,\n      y: closestY\n    } = getClosestIntersection(x, y);\n    const newX = Math.round((x - marginLeft) / scale); // Calcul de la colonne la plus proche\n    const newY = Math.round((y - marginTop) / scale); // Calcul de la ligne la plus proche\n\n    //console.log(\"ix\", newX, \" iy\", newY);\n\n    if (isValidPoint(x, y)) {\n      // Ajouter le point\n      setPoints(prevPoints => [...prevPoints, {\n        x: closestX,\n        y: closestY\n      }]);\n\n      // Mettre � jour la case correspondante dans la matrice plateau\n      const newPlateau = plateau.map((row, rowIndex) => row.map((value, colIndex) => rowIndex === newY + 1 && colIndex === newX + 1 ? currentPlayer : value));\n\n      // Mettre � jour l'�tat plateau avec la nouvelle matrice\n      setPlateau(newPlateau);\n      setCurrentPlayer(currentPlayer % totalPlayers + 1);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(Stage, {\n    width: marginLeft + width + marginRight,\n    height: marginTop + height + marginBottom,\n    onClick: handleClick,\n    onMouseMove: handleMouseMove,\n    children: /*#__PURE__*/_jsxDEV(Layer, {\n      children: [renderHorizontalLines(), renderVerticalLines(), /*#__PURE__*/_jsxDEV(Line, {\n        points: [0, 0, marginLeft + width + marginRight, 0],\n        stroke: \"black\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 120,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Line, {\n        points: [0, 0, 0, marginTop + height + marginBottom],\n        stroke: \"black\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 121,\n        columnNumber: 17\n      }, this), points.map((point, index) => /*#__PURE__*/_jsxDEV(Circle, {\n        x: point.x,\n        y: point.y,\n        radius: 5,\n        fill: \"red\"\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 125,\n        columnNumber: 21\n      }, this)), isValidPoint(mousePos.x, mousePos.y) && /*#__PURE__*/_jsxDEV(Circle, {\n        x: mousePos.x,\n        y: mousePos.y,\n        radius: 10,\n        fill: \"red\",\n        opacity: 0.5 // Opacit� de 50%\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 136,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 115,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 109,\n    columnNumber: 9\n  }, this);\n};\n\n// Valeurs par d�faut pour les props\n_s(Page, \"cLli8nqEaW3i/yWi+2PKFseCfbA=\");\n_c = Page;\nPage.defaultProps = {\n  numRows: 22,\n  numCols: 10\n};\nexport default Page;\nvar _c;\n$RefreshReg$(_c, \"Page\");","map":{"version":3,"names":["React","useState","Stage","Layer","Line","Circle","jsxDEV","_jsxDEV","Page","numRows","numCols","plateau","setPlateau","_s","currentPlayer","setCurrentPlayer","totalPlayers","width","height","marginTop","marginBottom","marginLeft","marginRight","a","b","scale","Math","floor","points","setPoints","playerPoints","setPlayerPoints","Array","from","length","renderHorizontalLines","lines","i","push","stroke","fileName","_jsxFileName","lineNumber","columnNumber","renderVerticalLines","getClosestIntersection","x","y","closestX","round","closestY","isValidPoint","mousePos","setMousePos","handleMouseMove","event","handleClick","target","getStage","getPointerPosition","newX","newY","prevPoints","newPlateau","map","row","rowIndex","value","colIndex","onClick","onMouseMove","children","point","index","radius","fill","opacity","_c","defaultProps","$RefreshReg$"],"sources":["C:/Users/User/Documents/Projects/GPL3/point-game/src/Page.js"],"sourcesContent":["import React, { useState } from 'react';\r\nimport { Stage, Layer, Line, Circle } from 'react-konva';\r\n\r\nconst Page = ({ numRows, numCols, plateau, setPlateau }) => {\r\n    const [currentPlayer, setCurrentPlayer] = useState(1);\r\n    let totalPlayers = 2;\r\n\r\n    const width = 750;\r\n    const height = 400;\r\n\r\n    const marginTop = 100;\r\n    const marginBottom = 60;\r\n    const marginLeft = 120;\r\n    const marginRight = 40;\r\n\r\n    let a = width / numCols;\r\n    let b = height / numRows;\r\n    let scale = a > b ? Math.floor(a) : Math.floor(a); // �chelle pour les graduations\r\n    scale = 50;\r\n\r\n    const [points, setPoints] = useState([]); // �tat pour les points\r\n\r\n    // Tableaux pour stocker les points de chaque joueur avec leur couleur\r\n    const [playerPoints, setPlayerPoints] = useState(Array.from({ length: totalPlayers }, () => []));\r\n\r\n\r\n    const renderHorizontalLines = () => {\r\n        const lines = [];\r\n        for (let i = 0; i <= numRows; i++) {\r\n            lines.push(\r\n                <Line\r\n                    key={`hline${i}`}\r\n                    points={[0, marginTop + i * scale, marginLeft + width + marginRight, marginTop + i * scale]}\r\n                    stroke=\"#ddd\"\r\n                />\r\n            );\r\n        }\r\n        return lines;\r\n    };\r\n\r\n    const renderVerticalLines = () => {\r\n        const lines = [];\r\n        for (let i = 0; i <= numCols; i++) {\r\n            lines.push(\r\n                <Line\r\n                    key={`vline${i}`}\r\n                    points={[marginLeft + i * scale, 0, marginLeft + i * scale, marginTop + height + marginBottom]}\r\n                    stroke=\"#ddd\"\r\n                />\r\n            );\r\n        }\r\n        return lines;\r\n    };\r\n\r\n    // Calculer l'intersection la plus proche\r\n    const getClosestIntersection = (x, y) => {\r\n        const closestX = Math.round((x - marginLeft) / scale) * scale;\r\n        const closestY = Math.round((y - marginTop) / scale) * scale;\r\n\r\n        return { x: closestX + marginLeft, y: closestY + marginTop };\r\n    };\r\n\r\n    const isValidPoint = (x, y) => {\r\n        return ((x > marginLeft - 20) && (x < marginLeft + width + 20) && (y > marginTop - 20) && (y < marginTop + height + 50));\r\n    }\r\n\r\n    const [mousePos, setMousePos] = useState({ x: 0, y: 0 }); // �tat pour la position de la souris\r\n\r\n    // G�rer le mouvement de la souris \r\n    const handleMouseMove = (event) => {/*\r\n        const { x, y } = event.target.getStage().getPointerPosition();\r\n        const { x: closestX, y: closestY } = getClosestIntersection(x, y);\r\n\r\n        if (isValidPoint(x, y)) {\r\n            setMousePos({ x: closestX, y: closestY });\r\n        }*/\r\n    };\r\n\r\n    // ************************************************************************************************************* //\r\n    // *********** ATO NO MIASA LE GAME **************************************************************************** //\r\n    // ************************************************************************************************************* //\r\n    const handleClick = (event) => {\r\n        const { x, y } = event.target.getStage().getPointerPosition();\r\n        const { x: closestX, y: closestY } = getClosestIntersection(x, y);\r\n\r\n\r\n        const newX = Math.round((x - marginLeft) / scale); // Calcul de la colonne la plus proche\r\n        const newY = Math.round((y - marginTop) / scale); // Calcul de la ligne la plus proche\r\n\r\n        //console.log(\"ix\", newX, \" iy\", newY);\r\n\r\n        if (isValidPoint(x, y)) {\r\n            // Ajouter le point\r\n            setPoints((prevPoints) => [...prevPoints, { x: closestX, y: closestY }]);\r\n\r\n            // Mettre � jour la case correspondante dans la matrice plateau\r\n            const newPlateau = plateau.map((row, rowIndex) =>\r\n                row.map((value, colIndex) => (rowIndex === newY + 1 && colIndex === newX + 1 ? currentPlayer : value))\r\n            );\r\n\r\n            // Mettre � jour l'�tat plateau avec la nouvelle matrice\r\n            setPlateau(newPlateau);\r\n\r\n            setCurrentPlayer((currentPlayer % totalPlayers) + 1); \r\n        }\r\n    };\r\n\r\n    return (\r\n        <Stage\r\n            width={marginLeft + width + marginRight}\r\n            height={marginTop + height + marginBottom}\r\n            onClick={handleClick}\r\n            onMouseMove={handleMouseMove}\r\n        >\r\n            <Layer>\r\n                {renderHorizontalLines()}\r\n                {renderVerticalLines()}\r\n\r\n                {/* Axes */}\r\n                <Line points={[0, 0, marginLeft + width + marginRight, 0]} stroke=\"black\" />\r\n                <Line points={[0, 0, 0, marginTop + height + marginBottom]} stroke=\"black\" />\r\n\r\n                {/* Rendu des points */}\r\n                {points.map((point, index) => (\r\n                    <Circle\r\n                        key={index}\r\n                        x={point.x}\r\n                        y={point.y}\r\n                        radius={5}\r\n                        fill=\"red\"\r\n                    />\r\n                ))}\r\n\r\n                {/* Cercle qui suit la souris */}\r\n                {isValidPoint(mousePos.x, mousePos.y) && (\r\n                    <Circle\r\n                        x={mousePos.x}\r\n                        y={mousePos.y}\r\n                        radius={10}\r\n                        fill=\"red\"\r\n                        opacity={0.5} // Opacit� de 50%\r\n                    />\r\n                )}\r\n\r\n            </Layer>\r\n        </Stage>\r\n    );\r\n};\r\n\r\n// Valeurs par d�faut pour les props\r\nPage.defaultProps = {\r\n    numRows: 22,\r\n    numCols: 10,\r\n};\r\n\r\nexport default Page;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}