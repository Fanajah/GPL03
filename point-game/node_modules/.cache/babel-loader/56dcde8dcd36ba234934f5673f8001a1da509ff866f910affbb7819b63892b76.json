{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\User\\\\Documents\\\\Projects\\\\GPL3\\\\point-game\\\\src\\\\Page.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport axios from 'axios';\nimport { Stage, Layer, Line, Circle } from 'react-konva';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Page = ({\n  numRows,\n  numCols,\n  plateau,\n  setPlateau,\n  width,\n  height\n}) => {\n  _s();\n  const [currentPlayer, setCurrentPlayer] = useState(1);\n  let totalPlayers = 2;\n  const minCellSize = 21; // Taille minimale de cellule\n  const maxCellSize = 100; // Taille maximale de cellule\n\n  const marginTop = 100;\n  const marginBottom = 60;\n  const marginLeft = 120;\n  const marginRight = 40;\n  let a = width / numCols;\n  let b = height / numRows;\n  let scale = a > b ? Math.floor(a) : Math.floor(a); // �chelle pour les graduations\n\n  const [playerPoints, setPlayerPoints] = useState(Array.from({\n    length: totalPlayers\n  }, () => []));\n  const [playersCircuitsList, setPlayersCircuitsList] = useState(Array(totalPlayers).fill(null).map(() => []));\n  const [cellSize, setCellSize] = useState(40); // Taille de cellule initiale\n\n  const drawClosedCircuit = () => {\n    let lines = [];\n    for (let playerIndex = 0; playerIndex < totalPlayers; playerIndex++) {\n      let circuits = playersCircuitsList[playerIndex];\n      let color = playerIndex === 0 ? \"red\" : playerIndex === 1 ? \"blue\" : playerIndex === 2 ? 'green' : 'black';\n      for (let circuitIndex = 0; circuitIndex < circuits.length; circuitIndex++) {\n        const circuit = circuits[circuitIndex];\n        const points = circuit.flatMap(point => [marginLeft + (point.x - 1) * scale, marginTop + (point.y - 1) * scale]);\n        lines.push( /*#__PURE__*/_jsxDEV(Line, {\n          points: points,\n          stroke: color,\n          strokeWidth: 2,\n          closed: true // Fermer le circuit\n          ,\n          lineJoin: \"round\",\n          lineCap: \"round\"\n        }, `player-${playerIndex}-circuit-${circuitIndex}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 37,\n          columnNumber: 21\n        }, this));\n      }\n    }\n    return lines;\n  };\n  const adaptSize = newSize => {\n    if (newSize >= 21 && newSize <= 100) {\n      // Limites de taille de cellule\n      setCellSize(newSize);\n    }\n  };\n  const handleSliderChange = e => {\n    const newSize = parseInt(e.target.value);\n    adaptSize(newSize);\n  };\n  const handleWheelZoom = e => {\n    e.evt.preventDefault();\n    const delta = Math.sign(e.evt.deltaY); // Direction de la molette (1 pour haut, -1 pour bas)\n    const zoomFactor = delta > 0 ? 1 / 1.1 : 1.1;\n    const newCellSize = cellSize * zoomFactor;\n    adaptSize(newCellSize);\n  };\n  const getClosestIntersection = (x, y) => {\n    const closestX = Math.round((x - marginLeft) / cellSize) * cellSize;\n    const closestY = Math.round((y - marginTop) / cellSize) * cellSize;\n    return {\n      x: closestX + marginLeft,\n      y: closestY + marginTop\n    };\n  };\n  const isValidPoint = (x, y) => {\n    return x > marginLeft - 20 && x < marginLeft + width + 20 && y > marginTop - 20 && y < marginTop + height + 20;\n  };\n  const [mousePos, setMousePos] = useState({\n    x: 0,\n    y: 0\n  });\n  const handleMouseMove = event => {\n    const {\n      x,\n      y\n    } = event.target.getStage().getPointerPosition();\n    const {\n      x: closestX,\n      y: closestY\n    } = getClosestIntersection(x, y);\n    if (isValidPoint(x, y)) {\n      setMousePos({\n        x: closestX,\n        y: closestY\n      });\n    }\n  };\n  const handleClick = event => {\n    const {\n      x,\n      y\n    } = event.target.getStage().getPointerPosition();\n    const {\n      x: closestX,\n      y: closestY\n    } = getClosestIntersection(x, y);\n    const newX = Math.round((x - marginLeft) / cellSize) + 1;\n    const newY = Math.round((y - marginTop) / cellSize) + 1;\n    if (isValidPoint(x, y) && plateau[newY][newX] === 0) {\n      const updatedPlayerPoints = [...playerPoints];\n      updatedPlayerPoints[currentPlayer - 1].push({\n        x: closestX,\n        y: closestY\n      });\n      setPlayerPoints(updatedPlayerPoints);\n      plateau[newY][newX] = currentPlayer;\n      setPlateau([...plateau]);\n      sendDataToServer(plateau, {\n        x: newX,\n        y: newY\n      });\n    }\n  };\n  const sendDataToServer = async (plateau, dernierPoint) => {\n    try {\n      const response = await axios.put(\"http://localhost:7001/api/Game/ProcessData\", {\n        CircuitList: playersCircuitsList,\n        plateau: plateau,\n        dernierPoint: dernierPoint,\n        currentPlayer: currentPlayer\n      });\n      setCurrentPlayer(response.data.currentPlayer);\n      const circuitData = response.data.circuitList.map(playerCircuits => playerCircuits.map(circuit => circuit.map(point => ({\n        x: point.x,\n        y: point.y\n      }))));\n      setPlayersCircuitsList(circuitData);\n      const plateauData = response.data.plateau.map(row => row.map(cell => cell));\n      setPlateau(plateauData);\n    } catch (error) {\n      console.error('Une erreur s\\'est produite lors de l\\'envoi des donn�es au serveur :', error);\n    }\n  };\n  const renderHorizontalLines = () => {\n    const lines = [];\n    const lineScale = 0.85; // Facteur d'�chelle pour l'�paisseur de ligne\n\n    for (let i = 1; i < numRows - 1; i++) {\n      const y = marginTop + i * cellSize + cellSize / 2;\n      lines.push( /*#__PURE__*/_jsxDEV(Line, {\n        points: [marginLeft + cellSize / 2, y, marginLeft + width + marginRight - cellSize / 2, y],\n        stroke: \"#4455C9CC\",\n        strokeWidth: 0.85 * lineScale\n      }, `hline${i}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 149,\n        columnNumber: 17\n      }, this));\n      for (let j = 1; j < 3; j++) {\n        lines.push( /*#__PURE__*/_jsxDEV(Line, {\n          points: [marginLeft + cellSize * j + cellSize / 2, y, marginLeft + width + marginRight - cellSize * j + cellSize / 2, y],\n          stroke: \"#FF0000CC\",\n          strokeWidth: 0.3 * lineScale\n        }, `hline${i}-${j}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 159,\n          columnNumber: 21\n        }, this));\n      }\n    }\n    return lines;\n  };\n  const renderVerticalLines = () => {\n    const lines = [];\n    const lineScale = 0.85; // Facteur d'�chelle pour l'�paisseur de ligne\n\n    for (let i = 1; i < numCols - 1; i++) {\n      const x = marginLeft + i * cellSize + cellSize / 2;\n      lines.push( /*#__PURE__*/_jsxDEV(Line, {\n        points: [x, marginTop + cellSize / 2, x, marginTop + height + marginBottom - cellSize / 2],\n        stroke: \"#4455C9CC\",\n        strokeWidth: 0.85 * lineScale\n      }, `vline${i}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 179,\n        columnNumber: 17\n      }, this));\n      for (let j = 1; j < 3; j++) {\n        lines.push( /*#__PURE__*/_jsxDEV(Line, {\n          points: [x, marginTop + cellSize * j + cellSize / 2, x, marginTop + height + marginBottom - cellSize * j + cellSize / 2],\n          stroke: \"#FF0000CC\",\n          strokeWidth: 0.3 * lineScale\n        }, `vline${i}-${j}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 189,\n          columnNumber: 21\n        }, this));\n      }\n    }\n    return lines;\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"input\", {\n      type: \"range\",\n      id: \"zoomSlider\",\n      min: minCellSize,\n      max: maxCellSize,\n      value: cellSize,\n      onChange: handleSliderChange\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 204,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Stage, {\n      width: marginLeft + width + marginRight,\n      height: marginTop + height + marginBottom,\n      onClick: handleClick,\n      onMouseMove: handleMouseMove,\n      onWheel: handleWheelZoom,\n      children: /*#__PURE__*/_jsxDEV(Layer, {\n        children: [renderHorizontalLines(), renderVerticalLines(), drawClosedCircuit(), /*#__PURE__*/_jsxDEV(Line, {\n          points: [0, 0, marginLeft + width + marginRight, 0],\n          stroke: \"black\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 224,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(Line, {\n          points: [0, 0, 0, marginTop + height + marginBottom],\n          stroke: \"black\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 225,\n          columnNumber: 21\n        }, this), playerPoints.map((points, playerIndex) => points.map((point, index) => /*#__PURE__*/_jsxDEV(Circle, {\n          x: point.x,\n          y: point.y,\n          radius: 5,\n          fill: playerIndex === 0 ? 'red' : playerIndex === 1 ? 'blue' : playerIndex === 2 ? 'green' : 'black'\n        }, `${playerIndex}-${index}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 229,\n          columnNumber: 29\n        }, this))), isValidPoint(mousePos.x, mousePos.y) && /*#__PURE__*/_jsxDEV(Circle, {\n          x: mousePos.x,\n          y: mousePos.y,\n          radius: 10,\n          fill: currentPlayer === 1 ? 'red' : currentPlayer === 2 ? 'blue' : currentPlayer === 3 ? 'green' : 'black',\n          opacity: 0.5\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 240,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 219,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 212,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 203,\n    columnNumber: 9\n  }, this);\n};\n_s(Page, \"CZnYcDz5zPFesZ17XkBN9z+NYxM=\");\n_c = Page;\nPage.defaultProps = {\n  numRows: 22,\n  numCols: 10\n};\nexport default Page;\n\n//const minCellSize = 21; // Taille minimale de cellule\n//const maxCellSize = 100; // Taille maximale de cellule\n\n//const Page = ({ numRows, numCols, plateau, setPlateau, width, height }) => {\n//    const [currentPlayer, setCurrentPlayer] = useState(1);\n//    let totalPlayers = 2;\n\n//    const marginTop = 100;\n//    const marginBottom = 60;\n//    const marginLeft = 120;\n//    const marginRight = 40;\n\n//    let a = width / numCols;\n//    let b = height / numRows;\n//    let scale = a > b ? Math.floor(a) : Math.floor(a); // �chelle pour les graduations\n\n//    const [playerPoints, setPlayerPoints] = useState(Array.from({ length: totalPlayers }, () => []));\n//    const [playersCircuitsList, setPlayersCircuitsList] = useState(Array(totalPlayers).fill(null).map(() => []));\n//    const [cellSize, setCellSize] = useState(40); // Taille de cellule initiale\n//    const zoomSlider = useRef(null);\n\n//    const adaptSize = (newSize) => {\n//        if (newSize >= 21 && newSize <= 100) { // Limites de taille de cellule\n//            setCellSize(newSize);\n//        }\n//    };\n\n//    const handleSliderChange = (e) => {\n//        const newSize = parseInt(e.target.value);\n//        adaptSize(newSize);\n//    };\n\n//    const handleWheelZoom = (e) => {\n//        e.evt.preventDefault();\n//        const delta = Math.sign(e.evt.deltaY); // Direction de la molette (1 pour haut, -1 pour bas)\n//        const zoomFactor = delta > 0 ? 1 / 1.1 : 1.1;\n\n//        const newCellSize = cellSize * zoomFactor;\n//        adaptSize(newCellSize);\n\n//        zoomSlider.current.value = cellSize;\n//    };\n\n//const drawClosedCircuit = () => {\n//    let lines = [];\n\n//    for (let playerIndex = 0; playerIndex < totalPlayers; playerIndex++) {\n//        let circuits = playersCircuitsList[playerIndex];\n//        let color = playerIndex === 0 ? \"red\" : playerIndex === 1 ? \"blue\" : playerIndex === 2 ? 'green' : 'black';\n\n//        for (let circuitIndex = 0; circuitIndex < circuits.length; circuitIndex++) {\n//            const circuit = circuits[circuitIndex];\n//            const points = circuit.flatMap(point => [marginLeft + (point.x - 1) * scale, marginTop + (point.y - 1) * scale]);\n\n//            lines.push(\n//                <Line\n//                    key={`player-${playerIndex}-circuit-${circuitIndex}`}\n//                    points={points}\n//                    stroke={color}\n//                    strokeWidth={2}\n//                    closed={true} // Fermer le circuit\n//                    lineJoin=\"round\"\n//                    lineCap=\"round\"\n//                />\n//            );\n//        }\n//    }\n\n//    return lines;\n//};\n\n//    const renderHorizontalLines = () => {\n//        const lines = [];\n//        for (let i = 0; i <= numRows; i++) {\n//            lines.push(\n//                <Line\n//                    key={`hline${i}`}\n//                    points={[0, marginTop + i * scale, marginLeft + width + marginRight, marginTop + i * scale]}\n//                    stroke=\"#ddd\"\n//                />\n//            );\n//        }\n//        return lines;\n//    };\n\n//    const renderVerticalLines = () => {\n//        const lines = [];\n//        for (let i = 0; i <= numCols; i++) {\n//            lines.push(\n//                <Line\n//                    key={`vline${i}`}\n//                    points={[marginLeft + i * scale, 0, marginLeft + i * scale, marginTop + height + marginBottom]}\n//                    stroke=\"#ddd\"\n//                />\n//            );\n//        }\n//        return lines;\n//    };\n\n//    const getClosestIntersection = (x, y) => {\n//        const closestX = Math.round((x - marginLeft) / cellSize) * cellSize;\n//        const closestY = Math.round((y - marginTop) / cellSize) * cellSize;\n\n//        return { x: closestX + marginLeft, y: closestY + marginTop };\n//    };\n\n//    const isValidPoint = (x, y) => {\n//        return ((x > marginLeft - 20) && (x < marginLeft + width + 20) && (y > marginTop - 20) && (y < marginTop + height + 20));\n//    };\n\n//    const [mousePos, setMousePos] = useState({ x: 0, y: 0 });\n\n//    const handleMouseMove = (event) => {\n//        const { x, y } = event.target.getStage().getPointerPosition();\n//        const { x: closestX, y: closestY } = getClosestIntersection(x, y);\n\n//        if (isValidPoint(x, y)) {\n//            setMousePos({ x: closestX, y: closestY });\n//        }\n//    };\n\n//    const handleClick = (event) => {\n//        const { x, y } = event.target.getStage().getPointerPosition();\n//        const { x: closestX, y: closestY } = getClosestIntersection(x, y);\n\n//        const newX = Math.round((x - marginLeft) / cellSize) + 1;\n//        const newY = Math.round((y - marginTop) / cellSize) + 1;\n\n//        if (isValidPoint(x, y) && plateau[newY][newX] === 0) {\n//            const updatedPlayerPoints = [...playerPoints];\n//            updatedPlayerPoints[currentPlayer - 1].push({ x: closestX, y: closestY });\n//            setPlayerPoints(updatedPlayerPoints);\n\n//            plateau[newY][newX] = currentPlayer;\n//            setPlateau([...plateau]);\n\n//            sendDataToServer(plateau, { x: newX, y: newY });\n//        }\n//    };\n\n//    const sendDataToServer = async (plateau, dernierPoint) => {\n//        try {\n//            const response = await axios.put(\"http://localhost:7001/api/Game/ProcessData\", {\n//                CircuitList: playersCircuitsList,\n//                plateau: plateau,\n//                dernierPoint: dernierPoint,\n//                currentPlayer: currentPlayer\n//            });\n\n//            setCurrentPlayer(response.data.currentPlayer);\n\n//            const circuitData = response.data.circuitList.map(playerCircuits =>\n//                playerCircuits.map(circuit => circuit.map(point => ({ x: point.x, y: point.y })))\n//            );\n\n//            setPlayersCircuitsList(circuitData);\n\n//            const plateauData = response.data.plateau.map(row =>\n//                row.map(cell => cell)\n//            );\n\n//            setPlateau(plateauData);\n\n//        } catch (error) {\n//            console.error('Une erreur s\\'est produite lors de l\\'envoi des donn�es au serveur :', error);\n//        }\n//    };\n\n//    return (\n//        <div>\n//            <input\n//                type=\"range\"\n//                id=\"zoomSlider\"\n//                ref={zoomSlider}\n//                min={minCellSize}\n//                max={maxCellSize}\n//                value={cellSize}\n//                onChange={handleSliderChange}\n//            />\n//            <Stage\n//                width={marginLeft + width + marginRight}\n//                height={marginTop + height + marginBottom}\n//                onClick={handleClick}\n//                onMouseMove={handleMouseMove}\n//                onWheel={handleWheelZoom}\n//            >\n//<Layer>\n//    {renderHorizontalLines()}\n//    {renderVerticalLines()}\n//    {drawClosedCircuit()}\n\n//    <Line points={[0, 0, marginLeft + width + marginRight, 0]} stroke=\"black\" />\n//    <Line points={[0, 0, 0, marginTop + height + marginBottom]} stroke=\"black\" />\n\n//    {playerPoints.map((points, playerIndex) =>\n//        points.map((point, index) => (\n//            <Circle\n//                key={`${playerIndex}-${index}`}\n//                x={point.x}\n//                y={point.y}\n//                radius={5}\n//                fill={playerIndex === 0 ? 'red' : playerIndex === 1 ? 'blue' : playerIndex === 2 ? 'green' : 'black'}\n//            />\n//        ))\n//    )}\n\n//    {isValidPoint(mousePos.x, mousePos.y) && (\n//        <Circle\n//            x={mousePos.x}\n//            y={mousePos.y}\n//            radius={10}\n//            fill={currentPlayer === 1 ? 'red' : currentPlayer === 2 ? 'blue' : currentPlayer === 3 ? 'green' : 'black'}\n//            opacity={0.5}\n//        />\n//    )}\n//</Layer>\n//            </Stage>\n//        </div>\n//    );\n//};\n\n//Page.defaultProps = {\n//    numRows: 22,\n//    numCols: 10,\n//};\n\n//export default Page;\nvar _c;\n$RefreshReg$(_c, \"Page\");","map":{"version":3,"names":["React","useState","axios","Stage","Layer","Line","Circle","jsxDEV","_jsxDEV","Page","numRows","numCols","plateau","setPlateau","width","height","_s","currentPlayer","setCurrentPlayer","totalPlayers","minCellSize","maxCellSize","marginTop","marginBottom","marginLeft","marginRight","a","b","scale","Math","floor","playerPoints","setPlayerPoints","Array","from","length","playersCircuitsList","setPlayersCircuitsList","fill","map","cellSize","setCellSize","drawClosedCircuit","lines","playerIndex","circuits","color","circuitIndex","circuit","points","flatMap","point","x","y","push","stroke","strokeWidth","closed","lineJoin","lineCap","fileName","_jsxFileName","lineNumber","columnNumber","adaptSize","newSize","handleSliderChange","e","parseInt","target","value","handleWheelZoom","evt","preventDefault","delta","sign","deltaY","zoomFactor","newCellSize","getClosestIntersection","closestX","round","closestY","isValidPoint","mousePos","setMousePos","handleMouseMove","event","getStage","getPointerPosition","handleClick","newX","newY","updatedPlayerPoints","sendDataToServer","dernierPoint","response","put","CircuitList","data","circuitData","circuitList","playerCircuits","plateauData","row","cell","error","console","renderHorizontalLines","lineScale","i","j","renderVerticalLines","children","type","id","min","max","onChange","onClick","onMouseMove","onWheel","index","radius","opacity","_c","defaultProps","$RefreshReg$"],"sources":["C:/Users/User/Documents/Projects/GPL3/point-game/src/Page.js"],"sourcesContent":["import React, { useState } from 'react';\nimport axios from 'axios';\nimport { Stage, Layer, Line, Circle } from 'react-konva';\n\nconst Page = ({ numRows, numCols, plateau, setPlateau, width, height }) => {\n    const [currentPlayer, setCurrentPlayer] = useState(1);\n    let totalPlayers = 2;\n\r\n    const minCellSize = 21; // Taille minimale de cellule\r\n    const maxCellSize = 100; // Taille maximale de cellule\n\n    const marginTop = 100;\n    const marginBottom = 60;\n    const marginLeft = 120;\n    const marginRight = 40;\n\n    let a = width / numCols;\n    let b = height / numRows;\n    let scale = a > b ? Math.floor(a) : Math.floor(a); // �chelle pour les graduations\n\n    const [playerPoints, setPlayerPoints] = useState(Array.from({ length: totalPlayers }, () => []));\n    const [playersCircuitsList, setPlayersCircuitsList] = useState(Array(totalPlayers).fill(null).map(() => []));\n    const [cellSize, setCellSize] = useState(40); // Taille de cellule initiale\n\n    const drawClosedCircuit = () => {\r\n        let lines = [];\r\n\r\n        for (let playerIndex = 0; playerIndex < totalPlayers; playerIndex++) {\r\n            let circuits = playersCircuitsList[playerIndex];\r\n            let color = playerIndex === 0 ? \"red\" : playerIndex === 1 ? \"blue\" : playerIndex === 2 ? 'green' : 'black';\r\n\r\n            for (let circuitIndex = 0; circuitIndex < circuits.length; circuitIndex++) {\r\n                const circuit = circuits[circuitIndex];\r\n                const points = circuit.flatMap(point => [marginLeft + (point.x - 1) * scale, marginTop + (point.y - 1) * scale]);\r\n\r\n                lines.push(\r\n                    <Line\r\n                        key={`player-${playerIndex}-circuit-${circuitIndex}`}\r\n                        points={points}\r\n                        stroke={color}\r\n                        strokeWidth={2}\r\n                        closed={true} // Fermer le circuit\r\n                        lineJoin=\"round\"\r\n                        lineCap=\"round\"\r\n                    />\r\n                );\r\n            }\r\n        }\r\n\r\n        return lines;\n    };\n\n    const adaptSize = (newSize) => {\n        if (newSize >= 21 && newSize <= 100) { // Limites de taille de cellule\n            setCellSize(newSize);\n        }\n    };\n\n    const handleSliderChange = (e) => {\n        const newSize = parseInt(e.target.value);\n        adaptSize(newSize);\n    };\n\n    const handleWheelZoom = (e) => {\n        e.evt.preventDefault();\n        const delta = Math.sign(e.evt.deltaY); // Direction de la molette (1 pour haut, -1 pour bas)\n        const zoomFactor = delta > 0 ? 1 / 1.1 : 1.1;\n\n        const newCellSize = cellSize * zoomFactor;\n        adaptSize(newCellSize);\n    };\n\n    const getClosestIntersection = (x, y) => {\n        const closestX = Math.round((x - marginLeft) / cellSize) * cellSize;\n        const closestY = Math.round((y - marginTop) / cellSize) * cellSize;\n\n        return { x: closestX + marginLeft, y: closestY + marginTop };\n    };\n\n    const isValidPoint = (x, y) => {\n        return ((x > marginLeft - 20) && (x < marginLeft + width + 20) && (y > marginTop - 20) && (y < marginTop + height + 20));\n    };\n\n    const [mousePos, setMousePos] = useState({ x: 0, y: 0 });\n\n    const handleMouseMove = (event) => {\n        const { x, y } = event.target.getStage().getPointerPosition();\n        const { x: closestX, y: closestY } = getClosestIntersection(x, y);\n\n        if (isValidPoint(x, y)) {\n            setMousePos({ x: closestX, y: closestY });\n        }\n    };\n\n    const handleClick = (event) => {\n        const { x, y } = event.target.getStage().getPointerPosition();\n        const { x: closestX, y: closestY } = getClosestIntersection(x, y);\n\n        const newX = Math.round((x - marginLeft) / cellSize) + 1;\n        const newY = Math.round((y - marginTop) / cellSize) + 1;\n\n        if (isValidPoint(x, y) && plateau[newY][newX] === 0) {\n            const updatedPlayerPoints = [...playerPoints];\n            updatedPlayerPoints[currentPlayer - 1].push({ x: closestX, y: closestY });\n            setPlayerPoints(updatedPlayerPoints);\n\n            plateau[newY][newX] = currentPlayer;\n            setPlateau([...plateau]);\n\n            sendDataToServer(plateau, { x: newX, y: newY });\n        }\n    };\n\n    const sendDataToServer = async (plateau, dernierPoint) => {\n        try {\n            const response = await axios.put(\"http://localhost:7001/api/Game/ProcessData\", {\n                CircuitList: playersCircuitsList,\n                plateau: plateau,\n                dernierPoint: dernierPoint,\n                currentPlayer: currentPlayer\n            });\n\n            setCurrentPlayer(response.data.currentPlayer);\n\n            const circuitData = response.data.circuitList.map(playerCircuits =>\n                playerCircuits.map(circuit => circuit.map(point => ({ x: point.x, y: point.y })))\n            );\n\n            setPlayersCircuitsList(circuitData);\n\n            const plateauData = response.data.plateau.map(row =>\n                row.map(cell => cell)\n            );\n\n            setPlateau(plateauData);\n\n        } catch (error) {\n            console.error('Une erreur s\\'est produite lors de l\\'envoi des donn�es au serveur :', error);\n        }\n    };\n\n    const renderHorizontalLines = () => {\n        const lines = [];\n        const lineScale = 0.85; // Facteur d'�chelle pour l'�paisseur de ligne\n\n        for (let i = 1; i < numRows - 1; i++) {\n            const y = marginTop + i * cellSize + cellSize / 2;\n            lines.push(\n                <Line\n                    key={`hline${i}`}\n                    points={[marginLeft + cellSize / 2, y, marginLeft + width + marginRight - cellSize / 2, y]}\n                    stroke=\"#4455C9CC\"\n                    strokeWidth={0.85 * lineScale}\n                />\n            );\n\n            for (let j = 1; j < 3; j++) {\n                lines.push(\n                    <Line\n                        key={`hline${i}-${j}`}\n                        points={[marginLeft + cellSize * j + cellSize / 2, y, marginLeft + width + marginRight - cellSize * j + cellSize / 2, y]}\n                        stroke=\"#FF0000CC\"\n                        strokeWidth={0.3 * lineScale}\n                    />\n                );\n            }\n        }\n\n        return lines;\n    };\n\n    const renderVerticalLines = () => {\n        const lines = [];\n        const lineScale = 0.85; // Facteur d'�chelle pour l'�paisseur de ligne\n\n        for (let i = 1; i < numCols - 1; i++) {\n            const x = marginLeft + i * cellSize + cellSize / 2;\n            lines.push(\n                <Line\n                    key={`vline${i}`}\n                    points={[x, marginTop + cellSize / 2, x, marginTop + height + marginBottom - cellSize / 2]}\n                    stroke=\"#4455C9CC\"\n                    strokeWidth={0.85 * lineScale}\n                />\n            );\n\n            for (let j = 1; j < 3; j++) {\n                lines.push(\n                    <Line\n                        key={`vline${i}-${j}`}\n                        points={[x, marginTop + cellSize * j + cellSize / 2, x, marginTop + height + marginBottom - cellSize * j + cellSize / 2]}\n                        stroke=\"#FF0000CC\"\n                        strokeWidth={0.3 * lineScale}\n                    />\n                );\n            }\n        }\n\n        return lines;\n    };\n\n    return (\n        <div>\n            <input\n                type=\"range\"\n                id=\"zoomSlider\"\n                min={minCellSize}\n                max={maxCellSize}\n                value={cellSize}\n                onChange={handleSliderChange}\n            />\n            <Stage\n                width={marginLeft + width + marginRight}\n                height={marginTop + height + marginBottom}\n                onClick={handleClick}\n                onMouseMove={handleMouseMove}\n                onWheel={handleWheelZoom}\n            >\n                <Layer>\n                    {renderHorizontalLines()}\n                    {renderVerticalLines()}\n                    {drawClosedCircuit()}\n\n                    <Line points={[0, 0, marginLeft + width + marginRight, 0]} stroke=\"black\" />\n                    <Line points={[0, 0, 0, marginTop + height + marginBottom]} stroke=\"black\" />\n\n                    {playerPoints.map((points, playerIndex) =>\n                        points.map((point, index) => (\n                            <Circle\n                                key={`${playerIndex}-${index}`}\n                                x={point.x}\n                                y={point.y}\n                                radius={5}\n                                fill={playerIndex === 0 ? 'red' : playerIndex === 1 ? 'blue' : playerIndex === 2 ? 'green' : 'black'}\n                            />\n                        ))\n                    )}\n\n                    {isValidPoint(mousePos.x, mousePos.y) && (\n                        <Circle\n                            x={mousePos.x}\n                            y={mousePos.y}\n                            radius={10}\n                            fill={currentPlayer === 1 ? 'red' : currentPlayer === 2 ? 'blue' : currentPlayer === 3 ? 'green' : 'black'}\n                            opacity={0.5}\n                        />\n                    )}\n                </Layer>\n            </Stage>\n        </div>\n    );\n};\n\nPage.defaultProps = {\n    numRows: 22,\n    numCols: 10,\n};\n\nexport default Page;\n\n\r\n//const minCellSize = 21; // Taille minimale de cellule\r\n//const maxCellSize = 100; // Taille maximale de cellule\n\n//const Page = ({ numRows, numCols, plateau, setPlateau, width, height }) => {\n//    const [currentPlayer, setCurrentPlayer] = useState(1);\n//    let totalPlayers = 2;\n\n//    const marginTop = 100;\n//    const marginBottom = 60;\n//    const marginLeft = 120;\n//    const marginRight = 40;\n\n//    let a = width / numCols;\n//    let b = height / numRows;\n//    let scale = a > b ? Math.floor(a) : Math.floor(a); // �chelle pour les graduations\n\n//    const [playerPoints, setPlayerPoints] = useState(Array.from({ length: totalPlayers }, () => []));\n//    const [playersCircuitsList, setPlayersCircuitsList] = useState(Array(totalPlayers).fill(null).map(() => []));\n//    const [cellSize, setCellSize] = useState(40); // Taille de cellule initiale\n//    const zoomSlider = useRef(null);\n\n//    const adaptSize = (newSize) => {\n//        if (newSize >= 21 && newSize <= 100) { // Limites de taille de cellule\n//            setCellSize(newSize);\n//        }\n//    };\n\n//    const handleSliderChange = (e) => {\n//        const newSize = parseInt(e.target.value);\n//        adaptSize(newSize);\n//    };\n\n//    const handleWheelZoom = (e) => {\n//        e.evt.preventDefault();\n//        const delta = Math.sign(e.evt.deltaY); // Direction de la molette (1 pour haut, -1 pour bas)\n//        const zoomFactor = delta > 0 ? 1 / 1.1 : 1.1;\n\n//        const newCellSize = cellSize * zoomFactor;\n//        adaptSize(newCellSize);\n\n//        zoomSlider.current.value = cellSize;\n//    };\n\n    //const drawClosedCircuit = () => {\r\n    //    let lines = [];\r\n\r\n    //    for (let playerIndex = 0; playerIndex < totalPlayers; playerIndex++) {\r\n    //        let circuits = playersCircuitsList[playerIndex];\r\n    //        let color = playerIndex === 0 ? \"red\" : playerIndex === 1 ? \"blue\" : playerIndex === 2 ? 'green' : 'black';\r\n\r\n    //        for (let circuitIndex = 0; circuitIndex < circuits.length; circuitIndex++) {\r\n    //            const circuit = circuits[circuitIndex];\r\n    //            const points = circuit.flatMap(point => [marginLeft + (point.x - 1) * scale, marginTop + (point.y - 1) * scale]);\r\n\r\n    //            lines.push(\r\n    //                <Line\r\n    //                    key={`player-${playerIndex}-circuit-${circuitIndex}`}\r\n    //                    points={points}\r\n    //                    stroke={color}\r\n    //                    strokeWidth={2}\r\n    //                    closed={true} // Fermer le circuit\r\n    //                    lineJoin=\"round\"\r\n    //                    lineCap=\"round\"\r\n    //                />\r\n    //            );\r\n    //        }\r\n    //    }\r\n\r\n    //    return lines;\n    //};\n\n//    const renderHorizontalLines = () => {\n//        const lines = [];\n//        for (let i = 0; i <= numRows; i++) {\n//            lines.push(\n//                <Line\n//                    key={`hline${i}`}\n//                    points={[0, marginTop + i * scale, marginLeft + width + marginRight, marginTop + i * scale]}\n//                    stroke=\"#ddd\"\n//                />\n//            );\n//        }\n//        return lines;\n//    };\n\n//    const renderVerticalLines = () => {\n//        const lines = [];\n//        for (let i = 0; i <= numCols; i++) {\n//            lines.push(\n//                <Line\n//                    key={`vline${i}`}\n//                    points={[marginLeft + i * scale, 0, marginLeft + i * scale, marginTop + height + marginBottom]}\n//                    stroke=\"#ddd\"\n//                />\n//            );\n//        }\n//        return lines;\n//    };\n\n//    const getClosestIntersection = (x, y) => {\n//        const closestX = Math.round((x - marginLeft) / cellSize) * cellSize;\n//        const closestY = Math.round((y - marginTop) / cellSize) * cellSize;\n\n//        return { x: closestX + marginLeft, y: closestY + marginTop };\n//    };\n\n//    const isValidPoint = (x, y) => {\n//        return ((x > marginLeft - 20) && (x < marginLeft + width + 20) && (y > marginTop - 20) && (y < marginTop + height + 20));\n//    };\n\n//    const [mousePos, setMousePos] = useState({ x: 0, y: 0 });\n\n//    const handleMouseMove = (event) => {\n//        const { x, y } = event.target.getStage().getPointerPosition();\n//        const { x: closestX, y: closestY } = getClosestIntersection(x, y);\n\n//        if (isValidPoint(x, y)) {\n//            setMousePos({ x: closestX, y: closestY });\n//        }\n//    };\n\n//    const handleClick = (event) => {\n//        const { x, y } = event.target.getStage().getPointerPosition();\n//        const { x: closestX, y: closestY } = getClosestIntersection(x, y);\n\n//        const newX = Math.round((x - marginLeft) / cellSize) + 1;\n//        const newY = Math.round((y - marginTop) / cellSize) + 1;\n\n//        if (isValidPoint(x, y) && plateau[newY][newX] === 0) {\n//            const updatedPlayerPoints = [...playerPoints];\n//            updatedPlayerPoints[currentPlayer - 1].push({ x: closestX, y: closestY });\n//            setPlayerPoints(updatedPlayerPoints);\n\n//            plateau[newY][newX] = currentPlayer;\n//            setPlateau([...plateau]);\n\n//            sendDataToServer(plateau, { x: newX, y: newY });\n//        }\n//    };\n\n//    const sendDataToServer = async (plateau, dernierPoint) => {\n//        try {\n//            const response = await axios.put(\"http://localhost:7001/api/Game/ProcessData\", {\n//                CircuitList: playersCircuitsList,\n//                plateau: plateau,\n//                dernierPoint: dernierPoint,\n//                currentPlayer: currentPlayer\n//            });\n\n//            setCurrentPlayer(response.data.currentPlayer);\n\n//            const circuitData = response.data.circuitList.map(playerCircuits =>\n//                playerCircuits.map(circuit => circuit.map(point => ({ x: point.x, y: point.y })))\n//            );\n\n//            setPlayersCircuitsList(circuitData);\n\n//            const plateauData = response.data.plateau.map(row =>\n//                row.map(cell => cell)\n//            );\n\n//            setPlateau(plateauData);\n\n//        } catch (error) {\n//            console.error('Une erreur s\\'est produite lors de l\\'envoi des donn�es au serveur :', error);\n//        }\n//    };\n\n//    return (\n//        <div>\n//            <input\n//                type=\"range\"\n//                id=\"zoomSlider\"\n//                ref={zoomSlider}\n//                min={minCellSize}\n//                max={maxCellSize}\n//                value={cellSize}\n//                onChange={handleSliderChange}\n//            />\n//            <Stage\n//                width={marginLeft + width + marginRight}\n//                height={marginTop + height + marginBottom}\n//                onClick={handleClick}\n//                onMouseMove={handleMouseMove}\n//                onWheel={handleWheelZoom}\n//            >\n                //<Layer>\n                //    {renderHorizontalLines()}\n                //    {renderVerticalLines()}\n                //    {drawClosedCircuit()}\n\n                //    <Line points={[0, 0, marginLeft + width + marginRight, 0]} stroke=\"black\" />\n                //    <Line points={[0, 0, 0, marginTop + height + marginBottom]} stroke=\"black\" />\n\n                //    {playerPoints.map((points, playerIndex) =>\n                //        points.map((point, index) => (\n                //            <Circle\n                //                key={`${playerIndex}-${index}`}\n                //                x={point.x}\n                //                y={point.y}\n                //                radius={5}\n                //                fill={playerIndex === 0 ? 'red' : playerIndex === 1 ? 'blue' : playerIndex === 2 ? 'green' : 'black'}\n                //            />\n                //        ))\n                //    )}\n\n                //    {isValidPoint(mousePos.x, mousePos.y) && (\n                //        <Circle\n                //            x={mousePos.x}\n                //            y={mousePos.y}\n                //            radius={10}\n                //            fill={currentPlayer === 1 ? 'red' : currentPlayer === 2 ? 'blue' : currentPlayer === 3 ? 'green' : 'black'}\n                //            opacity={0.5}\n                //        />\n                //    )}\n                //</Layer>\n//            </Stage>\n//        </div>\n//    );\n//};\n\n//Page.defaultProps = {\n//    numRows: 22,\n//    numCols: 10,\n//};\n\n//export default Page;\n"],"mappings":"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C/C,EAAA,CAvPIP,IAAI;AAAAoH,EAAA,GAAJpH,IAAI;AAyPVA,IAAI,CAACqH,YAAY,GAAG;EAChBpH,OAAO,EAAE,EAAE;EACXC,OAAO,EAAE;AACb,CAAC;AAED,eAAeF,IAAI;;AAGnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEI;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA,IAAAoH,EAAA;AAAAE,YAAA,CAAAF,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}