{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\User\\\\Documents\\\\Projects\\\\GPL3\\\\point-game\\\\src\\\\Page.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport axios from 'axios';\nimport { Stage, Layer, Line, Circle } from 'react-konva';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Page = ({\n  numRows,\n  numCols,\n  plateau,\n  setPlateau\n}) => {\n  _s();\n  const [currentPlayer, setCurrentPlayer] = useState(1);\n  let totalPlayers = 2;\n  const width = 750;\n  const height = 400;\n  const marginTop = 100;\n  const marginBottom = 60;\n  const marginLeft = 120;\n  const marginRight = 40;\n  let a = width / numCols;\n  let b = height / numRows;\n  let scale = a > b ? Math.floor(a) : Math.floor(a); // �chelle pour les graduations\n  scale = 50;\n\n  // Tableaux pour stocker les points de chaque joueur avec leur couleur\n  const [playerPoints, setPlayerPoints] = useState(Array.from({\n    length: totalPlayers\n  }, () => []));\n\n  // Initialisation des circuits pour chaque joueur\n  let playersCircuitsList = Array(totalPlayers).fill(null).map(() => []);\n  const generateRandomPointsList = count => {\n    const points = [];\n    for (let i = 0; i < count; i++) {\n      const x = Math.floor(Math.random() * numCols);\n      const y = Math.floor(Math.random() * numRows);\n      points.push({\n        x,\n        y\n      });\n    }\n    return points;\n  };\n\n  //playersCircuitsList[0].push(generateRandomPointsList(4));\n  //playersCircuitsList[0].push(generateRandomPointsList(4));\n  //playersCircuitsList[1].push(generateRandomPointsList(4));\n\n  const drawClosedCircuit = () => {\n    let lines = [];\n    for (let playerIndex = 0; playerIndex < totalPlayers; playerIndex++) {\n      let circuits = playersCircuitsList[playerIndex];\n      let color = playerIndex === 0 ? \"red\" : \"blue\"; // Vous pouvez ajouter plus de couleurs si n�cessaire\n\n      for (let circuitIndex = 0; circuitIndex < circuits.length; circuitIndex++) {\n        const circuit = circuits[circuitIndex];\n        const points = circuit.flatMap(point => [marginLeft + point.x * scale, marginTop + point.y * scale]);\n        lines.push( /*#__PURE__*/_jsxDEV(Line, {\n          points: points,\n          stroke: color,\n          strokeWidth: 2,\n          closed: true // Fermer le circuit\n          ,\n          lineJoin: \"round\",\n          lineCap: \"round\"\n        }, `player-${playerIndex}-circuit-${circuitIndex}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 55,\n          columnNumber: 21\n        }, this));\n      }\n    }\n    return lines;\n  };\n  const renderHorizontalLines = () => {\n    const lines = [];\n    for (let i = 0; i <= numRows; i++) {\n      lines.push( /*#__PURE__*/_jsxDEV(Line, {\n        points: [0, marginTop + i * scale, marginLeft + width + marginRight, marginTop + i * scale],\n        stroke: \"#ddd\"\n      }, `hline${i}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 75,\n        columnNumber: 17\n      }, this));\n    }\n    return lines;\n  };\n  const renderVerticalLines = () => {\n    const lines = [];\n    for (let i = 0; i <= numCols; i++) {\n      lines.push( /*#__PURE__*/_jsxDEV(Line, {\n        points: [marginLeft + i * scale, 0, marginLeft + i * scale, marginTop + height + marginBottom],\n        stroke: \"#ddd\"\n      }, `vline${i}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 89,\n        columnNumber: 17\n      }, this));\n    }\n    return lines;\n  };\n\n  // Calculer l'intersection la plus proche\n  const getClosestIntersection = (x, y) => {\n    const closestX = Math.round((x - marginLeft) / scale) * scale;\n    const closestY = Math.round((y - marginTop) / scale) * scale;\n    return {\n      x: closestX + marginLeft,\n      y: closestY + marginTop\n    };\n  };\n  const isValidPoint = (x, y) => {\n    return x > marginLeft - 20 && x < marginLeft + width + 20 && y > marginTop - 20 && y < marginTop + height + 20;\n  };\n  const [mousePos, setMousePos] = useState({\n    x: 0,\n    y: 0\n  }); // �tat pour la position de la souris\n\n  // G�rer le mouvement de la souris \n  const handleMouseMove = event => {\n    const {\n      x,\n      y\n    } = event.target.getStage().getPointerPosition();\n    const {\n      x: closestX,\n      y: closestY\n    } = getClosestIntersection(x, y);\n    if (isValidPoint(x, y)) {\n      setMousePos({\n        x: closestX,\n        y: closestY\n      });\n    }\n  };\n\n  // ************************************************************************************************************* //\n  // *********** ATO NO MIASA LE GAME **************************************************************************** //\n  // ************************************************************************************************************* //\n  const handleClick = event => {\n    const {\n      x,\n      y\n    } = event.target.getStage().getPointerPosition();\n    const {\n      x: closestX,\n      y: closestY\n    } = getClosestIntersection(x, y);\n    const newX = Math.round((x - marginLeft) / scale) + 1; // Calcul de la colonne la plus proche\n    const newY = Math.round((y - marginTop) / scale) + 1; // Calcul de la ligne la plus proche\n\n    //console.log(\"ix\", newX, \" iy\", newY);\n\n    if (isValidPoint(x, y)) {\n      // Ajouter le point au joueur courant\n      const updatedPlayerPoints = [...playerPoints];\n      updatedPlayerPoints[currentPlayer - 1].push({\n        x: closestX,\n        y: closestY\n      });\n      setPlayerPoints(updatedPlayerPoints);\n\n      // Mettre � jour la case correspondante dans la matrice plateau\n      //const newPlateau = plateau.map((row, rowIndex) =>\n      //    row.map((value, colIndex) => (rowIndex === newY && colIndex === newX ? currentPlayer : value))\n      //);\n\n      plateau[newY][newX] = currentPlayer;\n\n      // Mettre � jour l'�tat plateau avec la nouvelle matrice\n      setPlateau(plateau);\n      //console.log(\"x\", newX, \" y\", newY);\n      //console.log(plateau, \" cp \", currentPlayer);\n\n      // Appel de la fonction avec les donn�es � envoyer\n      sendDataToServer(newPlateau, {\n        x: newX + 1,\n        y: newY + 1\n      });\n      setCurrentPlayer(currentPlayer % totalPlayers + 1);\n    }\n  };\n  const sendDataToServer = async (plateau, dernierPoint) => {\n    try {\n      const response = await axios.put(\"https://localhost:44356/api/Game/ProcessData\", {\n        circuitList: playersCircuitsList,\n        plateau: plateau,\n        dernierPoint: dernierPoint,\n        currentPlayer: currentPlayer\n      });\n      console.log(response.data);\n    } catch (error) {\n      console.error('Une erreur s\\'est produite lors de l\\'envoi des donn�es au serveur :', error);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(Stage, {\n    width: marginLeft + width + marginRight,\n    height: marginTop + height + marginBottom,\n    onClick: handleClick,\n    onMouseMove: handleMouseMove,\n    children: /*#__PURE__*/_jsxDEV(Layer, {\n      children: [renderHorizontalLines(), renderVerticalLines(), drawClosedCircuit(), /*#__PURE__*/_jsxDEV(Line, {\n        points: [0, 0, marginLeft + width + marginRight, 0],\n        stroke: \"black\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 193,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Line, {\n        points: [0, 0, 0, marginTop + height + marginBottom],\n        stroke: \"black\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 194,\n        columnNumber: 17\n      }, this), playerPoints.map((points, playerIndex) => points.map((point, index) => /*#__PURE__*/_jsxDEV(Circle, {\n        x: point.x,\n        y: point.y,\n        radius: 5,\n        fill: playerIndex === 0 ? 'red' : 'blue' // Exemple de couleurs diff�rentes pour les joueurs\n      }, `${playerIndex}-${index}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 199,\n        columnNumber: 25\n      }, this))), isValidPoint(mousePos.x, mousePos.y) && /*#__PURE__*/_jsxDEV(Circle, {\n        x: mousePos.x,\n        y: mousePos.y,\n        radius: 10,\n        fill: currentPlayer === 1 ? 'red' : 'blue',\n        opacity: 0.5 // Opacit� de 50%\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 211,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 186,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 180,\n    columnNumber: 9\n  }, this);\n};\n\n// Valeurs par d�faut pour les props\n_s(Page, \"Lhnf0uBf89Qeisc335UNWdCbTTM=\");\n_c = Page;\nPage.defaultProps = {\n  numRows: 22,\n  numCols: 10\n};\nexport default Page;\nvar _c;\n$RefreshReg$(_c, \"Page\");","map":{"version":3,"names":["React","useState","axios","Stage","Layer","Line","Circle","jsxDEV","_jsxDEV","Page","numRows","numCols","plateau","setPlateau","_s","currentPlayer","setCurrentPlayer","totalPlayers","width","height","marginTop","marginBottom","marginLeft","marginRight","a","b","scale","Math","floor","playerPoints","setPlayerPoints","Array","from","length","playersCircuitsList","fill","map","generateRandomPointsList","count","points","i","x","random","y","push","drawClosedCircuit","lines","playerIndex","circuits","color","circuitIndex","circuit","flatMap","point","stroke","strokeWidth","closed","lineJoin","lineCap","fileName","_jsxFileName","lineNumber","columnNumber","renderHorizontalLines","renderVerticalLines","getClosestIntersection","closestX","round","closestY","isValidPoint","mousePos","setMousePos","handleMouseMove","event","target","getStage","getPointerPosition","handleClick","newX","newY","updatedPlayerPoints","sendDataToServer","newPlateau","dernierPoint","response","put","circuitList","console","log","data","error","onClick","onMouseMove","children","index","radius","opacity","_c","defaultProps","$RefreshReg$"],"sources":["C:/Users/User/Documents/Projects/GPL3/point-game/src/Page.js"],"sourcesContent":["import React, { useState } from 'react';\nimport axios from 'axios';\nimport { Stage, Layer, Line, Circle } from 'react-konva';\n\nconst Page = ({ numRows, numCols, plateau, setPlateau }) => {\n    const [currentPlayer, setCurrentPlayer] = useState(1);\n    let totalPlayers = 2;\n\n    const width = 750;\n    const height = 400;\n\n    const marginTop = 100;\n    const marginBottom = 60;\n    const marginLeft = 120;\n    const marginRight = 40;\n\n    let a = width / numCols;\n    let b = height / numRows;\n    let scale = a > b ? Math.floor(a) : Math.floor(a); // �chelle pour les graduations\n    scale = 50;\n\n    // Tableaux pour stocker les points de chaque joueur avec leur couleur\n    const [playerPoints, setPlayerPoints] = useState(Array.from({ length: totalPlayers }, () => []));\n\n\n    // Initialisation des circuits pour chaque joueur\r\n    let playersCircuitsList = Array(totalPlayers).fill(null).map(() => []);\n\n    const generateRandomPointsList = (count) => {\r\n        const points = [];\r\n        for (let i = 0; i < count; i++) {\r\n            const x = Math.floor(Math.random() * numCols);\r\n            const y = Math.floor(Math.random() * numRows);\r\n            points.push({ x, y });\r\n        }\r\n        return points;\r\n    };\r\n\r\n    //playersCircuitsList[0].push(generateRandomPointsList(4));\r\n    //playersCircuitsList[0].push(generateRandomPointsList(4));\r\n    //playersCircuitsList[1].push(generateRandomPointsList(4));\n\n    const drawClosedCircuit = () => {\r\n        let lines = [];\r\n\r\n        for (let playerIndex = 0; playerIndex < totalPlayers; playerIndex++) {\r\n            let circuits = playersCircuitsList[playerIndex];\r\n            let color = playerIndex === 0 ? \"red\" : \"blue\"; // Vous pouvez ajouter plus de couleurs si n�cessaire\r\n\r\n            for (let circuitIndex = 0; circuitIndex < circuits.length; circuitIndex++) {\r\n                const circuit = circuits[circuitIndex];\r\n                const points = circuit.flatMap(point => [marginLeft + point.x * scale, marginTop + point.y * scale]);\r\n\r\n                lines.push(\r\n                    <Line\r\n                        key={`player-${playerIndex}-circuit-${circuitIndex}`}\r\n                        points={points}\r\n                        stroke={color}\r\n                        strokeWidth={2}\r\n                        closed={true} // Fermer le circuit\r\n                        lineJoin=\"round\"\r\n                        lineCap=\"round\"\r\n                    />\r\n                );\r\n            }\r\n        }\r\n\r\n        return lines;\n    };\n\n    const renderHorizontalLines = () => {\n        const lines = [];\n        for (let i = 0; i <= numRows; i++) {\n            lines.push(\n                <Line\n                    key={`hline${i}`}\n                    points={[0, marginTop + i * scale, marginLeft + width + marginRight, marginTop + i * scale]}\n                    stroke=\"#ddd\"\n                />\n            );\n        }\n        return lines;\n    };\n\n    const renderVerticalLines = () => {\n        const lines = [];\n        for (let i = 0; i <= numCols; i++) {\n            lines.push(\n                <Line\n                    key={`vline${i}`}\n                    points={[marginLeft + i * scale, 0, marginLeft + i * scale, marginTop + height + marginBottom]}\n                    stroke=\"#ddd\"\n                />\n            );\n        }\n        return lines;\n    };\n\n    // Calculer l'intersection la plus proche\n    const getClosestIntersection = (x, y) => {\n        const closestX = Math.round((x - marginLeft) / scale) * scale;\n        const closestY = Math.round((y - marginTop) / scale) * scale;\n\n        return { x: closestX + marginLeft, y: closestY + marginTop };\n    };\n\n    const isValidPoint = (x, y) => {\n        return ((x > marginLeft - 20) && (x < marginLeft + width + 20) && (y > marginTop - 20) && (y < marginTop + height + 20));\n    }\n\n    const [mousePos, setMousePos] = useState({ x: 0, y: 0 }); // �tat pour la position de la souris\n\n    // G�rer le mouvement de la souris \n    const handleMouseMove = (event) => {\n        const { x, y } = event.target.getStage().getPointerPosition();\n        const { x: closestX, y: closestY } = getClosestIntersection(x, y);\n\n        if (isValidPoint(x, y)) {\n            setMousePos({ x: closestX, y: closestY });\n        }\n    };\n\n    // ************************************************************************************************************* //\n    // *********** ATO NO MIASA LE GAME **************************************************************************** //\n    // ************************************************************************************************************* //\n    const handleClick = (event) => {\n        const { x, y } = event.target.getStage().getPointerPosition();\n        const { x: closestX, y: closestY } = getClosestIntersection(x, y);\n\n\n        const newX = Math.round((x - marginLeft) / scale) + 1; // Calcul de la colonne la plus proche\n        const newY = Math.round((y - marginTop) / scale) + 1; // Calcul de la ligne la plus proche\n\n        //console.log(\"ix\", newX, \" iy\", newY);\n\n        if (isValidPoint(x, y)) {\n            // Ajouter le point au joueur courant\n            const updatedPlayerPoints = [...playerPoints];\n            updatedPlayerPoints[currentPlayer - 1].push({ x: closestX, y: closestY });\n            setPlayerPoints(updatedPlayerPoints);\n\n\n            // Mettre � jour la case correspondante dans la matrice plateau\n            //const newPlateau = plateau.map((row, rowIndex) =>\n            //    row.map((value, colIndex) => (rowIndex === newY && colIndex === newX ? currentPlayer : value))\n            //);\n\n            plateau[newY][newX] = currentPlayer;\n\n\n            // Mettre � jour l'�tat plateau avec la nouvelle matrice\n            setPlateau(plateau);\n            //console.log(\"x\", newX, \" y\", newY);\n            //console.log(plateau, \" cp \", currentPlayer);\n\n            // Appel de la fonction avec les donn�es � envoyer\n            sendDataToServer(newPlateau, { x: newX + 1, y: newY + 1 });\n\n            setCurrentPlayer((currentPlayer % totalPlayers) + 1); \n        }\n    };\n\n    const sendDataToServer = async (plateau, dernierPoint) => {\n        try {\n            const response = await axios.put(\"https://localhost:44356/api/Game/ProcessData\", {\n                circuitList: playersCircuitsList,\n                plateau: plateau,\n                dernierPoint: dernierPoint,\n                currentPlayer: currentPlayer\n            });\n\n            console.log(response.data);\n\n        } catch (error) {\n            console.error('Une erreur s\\'est produite lors de l\\'envoi des donn�es au serveur :', error);\n        }\n    };\n\n    return (\n        <Stage\n            width={marginLeft + width + marginRight}\n            height={marginTop + height + marginBottom}\n            onClick={handleClick}\n            onMouseMove={handleMouseMove}\n        >\n            <Layer>\n                {renderHorizontalLines()}\n                {renderVerticalLines()}\n\r\n                {drawClosedCircuit()}\n\n                {/* Axes */}\n                <Line points={[0, 0, marginLeft + width + marginRight, 0]} stroke=\"black\" />\n                <Line points={[0, 0, 0, marginTop + height + marginBottom]} stroke=\"black\" />\n\n                {/* Rendu des points par joueur */}\n                {playerPoints.map((points, playerIndex) =>\n                    points.map((point, index) => (\n                        <Circle\n                            key={`${playerIndex}-${index}`}\n                            x={point.x}\n                            y={point.y}\n                            radius={5}\n                            fill={playerIndex === 0 ? 'red' : 'blue'} // Exemple de couleurs diff�rentes pour les joueurs\n                        />\n                    ))\n                )}\n\n                {/* Cercle qui suit la souris */}\n                {isValidPoint(mousePos.x, mousePos.y) && (\n                    <Circle\n                        x={mousePos.x}\n                        y={mousePos.y}\n                        radius={10}\n                        fill={currentPlayer === 1 ? 'red' : 'blue'}\n                        opacity={0.5} // Opacit� de 50%\n                    />\n                )}\n\n            </Layer>\n        </Stage>\n    );\n};\n\n// Valeurs par d�faut pour les props\nPage.defaultProps = {\n    numRows: 22,\n    numCols: 10,\n};\n\nexport default Page;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}